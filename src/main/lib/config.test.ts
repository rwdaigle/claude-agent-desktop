import { describe, expect, test } from 'bun:test';

/**
 * Tests for the allowed directories configuration logic.
 *
 * Note: Direct testing of config.ts requires mocking Electron's app module,
 * which has limitations with Bun's test runner. These tests validate the
 * data structures and logic that would be used by the config functions.
 */

describe('Allowed Directories Config Logic', () => {
  describe('directory filtering', () => {
    // Tests the filtering logic used in setAllowedDirectories
    const filterDirectories = (directories: string[]): string[] => {
      return directories.filter((d) => d.trim()).map((d) => d.trim());
    };

    test('filters empty strings', () => {
      const input = ['', '/path/one', '  ', '/path/two'];
      const result = filterDirectories(input);
      expect(result).toEqual(['/path/one', '/path/two']);
    });

    test('trims whitespace', () => {
      const input = ['  /path/one  ', '/path/two  '];
      const result = filterDirectories(input);
      expect(result).toEqual(['/path/one', '/path/two']);
    });

    test('returns empty array for all empty strings', () => {
      const input = ['', '  ', '   '];
      const result = filterDirectories(input);
      expect(result).toEqual([]);
    });

    test('preserves valid paths', () => {
      const input = ['~', '/Users/test', '/home/user/projects'];
      const result = filterDirectories(input);
      expect(result).toEqual(['~', '/Users/test', '/home/user/projects']);
    });
  });

  describe('duplicate prevention', () => {
    // Tests the logic used in addAllowedDirectory
    const addWithoutDuplicates = (dirs: string[], newDir: string): string[] => {
      const normalized = newDir.trim();
      if (normalized && !dirs.includes(normalized)) {
        return [...dirs, normalized];
      }
      return dirs;
    };

    test('adds new directory', () => {
      const dirs = ['/path/one'];
      const result = addWithoutDuplicates(dirs, '/path/two');
      expect(result).toEqual(['/path/one', '/path/two']);
    });

    test('prevents duplicate directory', () => {
      const dirs = ['/path/one', '/path/two'];
      const result = addWithoutDuplicates(dirs, '/path/one');
      expect(result).toEqual(['/path/one', '/path/two']);
    });

    test('ignores empty string', () => {
      const dirs = ['/path/one'];
      const result = addWithoutDuplicates(dirs, '');
      expect(result).toEqual(['/path/one']);
    });

    test('ignores whitespace-only string', () => {
      const dirs = ['/path/one'];
      const result = addWithoutDuplicates(dirs, '   ');
      expect(result).toEqual(['/path/one']);
    });
  });

  describe('directory removal', () => {
    // Tests the logic used in removeAllowedDirectory
    const removeDirectory = (dirs: string[], toRemove: string): string[] => {
      const normalized = toRemove.trim();
      return dirs.filter((d) => d !== normalized);
    };

    test('removes directory from list', () => {
      const dirs = ['/path/one', '/path/two', '/path/three'];
      const result = removeDirectory(dirs, '/path/two');
      expect(result).toEqual(['/path/one', '/path/three']);
    });

    test('returns unchanged list if directory not found', () => {
      const dirs = ['/path/one', '/path/two'];
      const result = removeDirectory(dirs, '/path/three');
      expect(result).toEqual(['/path/one', '/path/two']);
    });

    test('removes first occurrence only', () => {
      const dirs = ['/path/one', '/path/two'];
      const result = removeDirectory(dirs, '/path/one');
      expect(result).toEqual(['/path/two']);
    });
  });

  describe('settings.json structure', () => {
    // Tests the settings.json structure generated by generateSettingsJson
    const generateSettings = (allowedDirs: string[]): object => {
      return {
        permissions: {
          additionalDirectories: allowedDirs
        }
      };
    };

    test('generates correct structure with directories', () => {
      const settings = generateSettings(['/path/one', '/path/two']);
      expect(settings).toEqual({
        permissions: {
          additionalDirectories: ['/path/one', '/path/two']
        }
      });
    });

    test('generates correct structure with home directory default', () => {
      const settings = generateSettings(['~']);
      expect(settings).toEqual({
        permissions: {
          additionalDirectories: ['~']
        }
      });
    });

    test('generates correct structure with empty array', () => {
      const settings = generateSettings([]);
      expect(settings).toEqual({
        permissions: {
          additionalDirectories: []
        }
      });
    });

    test('generates valid JSON string', () => {
      const settings = generateSettings(['~', '/Users/test']);
      const jsonString = JSON.stringify(settings, null, 2);
      const parsed = JSON.parse(jsonString);
      expect(parsed).toEqual(settings);
    });
  });

  describe('default values', () => {
    test('default allowed directories is home directory', () => {
      const defaultAllowedDirectories = ['~'];
      expect(defaultAllowedDirectories).toEqual(['~']);
    });

    test('default workspace directory suffix', () => {
      const workspaceSuffix = '.claude-agent';
      expect(workspaceSuffix).toBe('.claude-agent');
    });
  });
});
